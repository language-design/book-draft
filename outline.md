Introduction
==============
* What is Language Design?
* What kind of Languages? DSLs vs. GPLs
* What is a Pattern?
* Why we chose Patterns
* Our particular Pattern form.
* General Forces addressed in the Patterns:
  Stakeholder integration, Tool considerations, IDE supportability,
  Implementation complexities, performance/scalability consequences,
  analyzability


Case Studies
===================
Introduce the case study DSLs used throughout the book 
I suggest we use a set of 3-6 case studies to illustrate
design decisions and alternatives throughout the book.


Patterns
=================

Structuring a Domain
----------------------------------

One language or many? What is the relationship between them? How do I
exploit language composition? How do I find the abstractions that should
do into a language?


Abstraction
--------------------------

What should go into the language? Can users define their own
abstractions in the language. If so, how? 


Notation
------------------------

Here we discuss the trade-offs between the various syntactic forms
(text, graphics, tables, symbols, ...) and tradeoffs among them.


Paradigms
------------------------

Programming languages come in several established flavours: functional,
imperative, reactive, ... In this chapter we discuss these paradigms and
outline their trade-offs.


Style Tradeoffs
---------------------
Dynamic vs. static typing, type inference vs. explicit typing,
Lispy style vs. COBOL style.


Relationship to Programming Languages
---------------------------------------------------
Code Generation, Interpretation, Domain Coverage, External DSLs
vs. Language Extension vs. Internal DSLs


How to apply the Patterns
=============================

What is a good "process" to build DSLs? Which steps do you take and
what are the preconditions for success? How do you use the patterns
in the process?